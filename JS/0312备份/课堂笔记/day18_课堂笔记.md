#### 昨日回顾

```
事件高级
	事件的两种注册方式
		1,传统方式:以on开头的属性形式,本质是给对象的属性赋值
		2,H5监听注册方式:addEventListener,本质是调用方法
	事件流的3个阶段
		事件捕获阶段:从根节点到事件源
		当前目标阶段:事件到达事件源
		事件冒泡阶段:从事件源到根节点
	事件对象
		概念
			触发事件的时候,系统会产生一个事件对象,包含了当前事件的所有信息
		属性
			type	获取当前事件的名称
			keyCode	获取事件触发的键的值的字符代码
			target	获取具体触发事件的子元素
		方法
			preventDefault() 阻止某些标签的默认行为
			stopPropagation() 阻止事件冒泡
	事件委托
		概念
			将事件绑定到父元素上(委托父类处理事件)
			通过事件冒泡来触发父类的事件
		好处
			可以提高效率
			可以动态的给新增的子元素绑定事件
	鼠标事件对象
		作用
			获取鼠标的坐标
		属性
			client:鼠标在可视区域的坐标
			page:鼠标在页面文档中的坐标
			screen:鼠标在屏幕中的坐标
BOM	
	概念
		浏览器对象模型
	组成
		window 窗口对象
			弹框相关
				alert()
				prompt()
				confirm()
			窗口相关
				open()
				close()
			定时器相关
				setTimeout() clearTimeout()
				setInterval() clearInterval()
		Location 地址栏对象
			属性
				href 设置或者返回url路径
			方法
				reload() 刷新
		history 历史记录对象
			方法
				back()
				forward()
				go()
		screen 屏幕对象
		navigator 浏览器对象
```

#### 对象分类

##### 全局对象

```
全局对象(Global Object)
	在浏览器环境中,js引擎会整合所有的script标签中的内容,产生一个window对象(代表全局对象)
全局变量
	在script标签下定义的变量
全局函数
	在script标签下定义的函数
关系
	全局变量其实是作为全局对象(GO对象)的一个属性存在的
	全局函数其实是作为全局对象(GO对象)的一个方法存在的
```

##### 活动对象

```
活动对象(Active Object)
	在函数被调用的时候,产生的一个对象,用来保存当前函数内部的执行环境
局部变量
	在函数里面定义的变量
局部函数
	在函数里面定义的函数
关系
	局部变量其实是作为活动对象(AO对象)的一个属性存在的
	局部函数其实是作为活动对象(AO对象)的一个方法存在的
```

#### 预编译

##### 全局预编译

```
概念
	就是在全局环境下(script标签下),js引擎的处理方式
流程
	1,先查找全局变量的声明,作为GO对象的属性名,值是undefined
	2,再查找全局函数的声明,作为GO对象的方法名,值是function
	3,从上往下依次执行代码(声明的语句会被略过)
结论
	在全局环境下,如果出现同名的变量和函数,预处理的时候,函数的优先级高
```

##### 函数预编译

```
概念
	就是在局部环境下(函数里面),js引擎的处理方式
流程
	1,在函数被调用的那一刻,就会为当前函数生成一个AO对象
	2,先查找局部变量和形参的声明,作为AO对象的属性名,值是undefined
	3,使用实参的值替换形参的值
	4,再查找局部函数的声明,作为AO对象的方法名,值是function
	3,从上往下依次执行代码(声明的语句会被略过)
结论
	在局部环境下,如果出现同名的变量和函数,预处理的时候,函数的优先级高
```

#### 作用域

```
概念
	就是一个区域,用于限定变量在某个范围内起作用
好处
	可以提高程序的可靠性,减少命令冲突(ES6语法),在同一个域中,不能定义相同的变量,否则会报错
分类
	全局作用域(在全局环境下)
		由script标签产生的区域,从计算机的角度可以理解为window对象(GO对象)管控的区域
		全局变量和全局函数都是在全局作用域下,在页面关闭的时候被销毁
	局部作用域(在函数里面)
		由函数产生的区域,从计算机的角度可以理解为当前函数对象(AO对象)管控的区域
		局部变量和局部函数都在局部作用域下,在函数执行完成之后被销毁
	块级作用域(ES6新增的,在{}中)
		ES6语法中,存在于if语句,for循环等{}中,{}包含的区域就是块级作用域
```

#### 作用域(链)

```
概念
	只要是代码,都会在一个作用域中.写在函数内部,就在局部作用域中,没有写在函数内部的,就在全局作用域中,如果这个作用域中还有函数,那么这个作用域内部又可以产生一个新的作用域,就形成作用域链
	
作用
	提供了查找机制,内部函数可以访问外部函数中的变量,使用链式查找来决定哪些数据能被内部函数访问
	
本质
	就是一个数据结构,函数内部可以嵌套函数,每一次嵌套都会形成一个新的作用域,把这些作用域串起来
	就形成作用域链
```

#### 原型

##### 实例成员和静态成员

```
实例成员
	在构造函数中,通过this添加的成员,都是实例成员
	实例成员只能通过实例化对象(new 出来的对象)访问
	
静态成员
	在构造函数本身上添加的成员,叫做静态成员
	静态成员只能通过构造函数访问

静态成员作用
	可以将一些公共的东西,比如毕业院校,国籍,民族,可以放在静态成员中,减少内存分配

举例
	饮水机和水杯
		如果把饮水机定义成实例成员,就相当于每一个学生都有一个饮水机,造成资源的浪费
		如果把水杯定义成静态的,就相当于所有学生共用一个水平,也不好,一般定义成实例
```

##### 原型的由来

```
出现的问题
	之前使用this定义方法的时候,每new一次,都会为对象的方法开辟一块空间,浪费内存
使用原型解决
	原型的本质
	  其实就是构造函数里面的一个属性prototype,可以看做类的静态成员,可以把公共方法定义在上面
	原型的好处
	  将方法定义在原型上,每次创建对象,就不需要为对象的方法重新分配空间,节省了内存
```



#### 存储对象

```
概念
	Web 存储 API 提供了 sessionStorage （会话存储） 和 localStorage（本地存储）两个存储对象来对网页的数据进行添加、删除、修改、查询操作。
	localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。
	sessionStorage 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。
	
特点
	数据都是存储在用户的浏览器中
	可以方便用户设置和读取数据,刷新页面也不会丢失数据
	容量有限,sessionStorage约5M,locationStorage约为20M
	只能存储字符串,可以将对象使用Json.stringify转成json之后再存储

方法
	getItem(keyname)	返回指定键的值
    setItem(keyname, value)	添加键和值，如果对应的值存在，则更新该键对应的值。
    removeItem(keyname)	移除键
    clear()	清除存储对象中所有的键
    
    Object.keys(localStorage) //获取本地存储中所有的键值对
    
 sessionStorage存储的特点
 	1,生命周期是关闭浏览器
 	2,在同一个窗口(页面)数据是可以共享(确保ip和端口一致)
 	3,以键值对方式存储数据
 
 localStorage存储的特点
 	1,生命周期是永久有效,除非手动删除,否则关闭浏览器也存在
 	2,在多个窗口(页面)数据是可以共享(确保ip和端口一致),仅限于同一个浏览器
 	3,以键值对方式存储数据
```

